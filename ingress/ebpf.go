package ingress

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"sync/atomic"
	"unsafe"

	"github.com/FerroO2000/goccia/internal"
	"github.com/FerroO2000/goccia/internal/config"
	"github.com/FerroO2000/goccia/internal/message"
	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
)

//////////////
//  CONFIG  //
//////////////

type ebpfObjs interface {
	Close() error
}

type ebpfObjsPtr[O any] interface {
	*O
	ebpfObjs
}

// EBPFLoadFn loads the embedded CollectionSpec for bpf.
// This function is generated by bpf2go
type EBPFLoadFn func() (*ebpf.CollectionSpec, error)

// EBPFLinkFn is used to link the given eBPF objects
// to a specific hook that implements the [link.Link] interface.
type EBPFLinkFn[O any, OPtr ebpfObjsPtr[O]] func(objs OPtr) (link.Link, error)

// EBPFRingBufferGetter is used to extract the ring buffer
// from the given eBPF objects.
type EBPFRingBufferGetter[O any, OPtr ebpfObjsPtr[O]] func(objs OPtr) *ebpf.Map

// Default values for the ebpf ingress stage configuration.
const (
	DefaultEBPFConfigUseUnsafe = false
)

// EBPFConfig is the configuration for the ebpf ingress stage.
type EBPFConfig[O any, OPtr ebpfObjsPtr[O]] struct {
	// LoadFn defines the function to load the eBPF spec.
	LoadFn EBPFLoadFn

	// LinkFn defines the function to link the eBPF program.
	LinkFn EBPFLinkFn[O, OPtr]

	// RingBufferGetter defines the function to get the ring buffer from the eBPF program.
	RingBufferGetter EBPFRingBufferGetter[O, OPtr]

	// UseUnsafe states whether the data read from the ring buffer should be
	// converted to a Go struct using an unsafe cast. Otherwise, the data is
	// converted with [binary.Read], which is slower.
	UseUnsafe bool

	// CollectionOptions defines the options for loading the eBPF collection.
	CollectionOptions *ebpf.CollectionOptions
}

// NewEBPFConfig returns the default configuration for the ebpf ingress stage.
func NewEBPFConfig[O any, OPtr ebpfObjsPtr[O]](
	loadFn EBPFLoadFn, attachFn EBPFLinkFn[O, OPtr], ringBufferGetter EBPFRingBufferGetter[O, OPtr],
) *EBPFConfig[O, OPtr] {

	return &EBPFConfig[O, OPtr]{
		LoadFn:            loadFn,
		LinkFn:            attachFn,
		RingBufferGetter:  ringBufferGetter,
		UseUnsafe:         DefaultEBPFConfigUseUnsafe,
		CollectionOptions: nil,
	}
}

// Validate checks the configuration.
func (c *EBPFConfig[O, OPtr]) Validate(_ *config.AnomalyCollector) {}

///////////////
//  MESSAGE  //
///////////////

var _ msgBody = (*EBPFMessage[any])(nil)

// EBPFMessage is the message type for the ebpf ingress stage.
type EBPFMessage[T any] struct {
	// Data is the parsed content of the data coming from the eBPF ring buffer.
	Data T
}

func newEBPFMessage[T any](data T) *EBPFMessage[T] {
	return &EBPFMessage[T]{
		Data: data,
	}
}

// Destroy cleans up the message.
func (m *EBPFMessage[T]) Destroy() {}

//////////////
//  SOURCE  //
//////////////

type ebpfSourceConfig struct {
	ringBufferMap *ebpf.Map
	useUnsafe     bool
}

type ebpfSourceMetrics struct {
	tel *internal.Telemetry

	receivedRecords atomic.Int64
	parsingErrors   atomic.Int64

	receivedBytes atomic.Int64
}

func newEBPFSourceMetrics(tel *internal.Telemetry) *ebpfSourceMetrics {
	return &ebpfSourceMetrics{
		tel: tel,
	}
}

func (esm *ebpfSourceMetrics) init() {
	esm.tel.NewCounter("received_records", func() int64 { return esm.receivedRecords.Load() })
	esm.tel.NewCounter("parsing_errors", func() int64 { return esm.parsingErrors.Load() })
	esm.tel.NewCounter("received_bytes", func() int64 { return esm.receivedBytes.Load() })
}

func (esm *ebpfSourceMetrics) incrementReceivedRecords() {
	esm.receivedRecords.Add(1)
}

func (esm *ebpfSourceMetrics) incrementParsingErrors() {
	esm.parsingErrors.Add(1)
}

func (esm *ebpfSourceMetrics) addReceivedBytes(amount int64) {
	esm.receivedBytes.Add(amount)
}

type ebpfSource[T any] struct {
	tel *internal.Telemetry

	cfg *ebpfSourceConfig

	rb        *ringbuf.Reader
	eventSize int

	metrics *ebpfSourceMetrics
}

func newEBPFSource[T any]() *ebpfSource[T] {
	return &ebpfSource[T]{}
}

func (es *ebpfSource[T]) setTelemetry(tel *internal.Telemetry) {
	es.tel = tel
}

func (es *ebpfSource[T]) init(cfg *ebpfSourceConfig) error {
	// Open the ring buffer
	rb, err := ringbuf.NewReader(cfg.ringBufferMap)
	if err != nil {
		es.tel.LogError("failed to create ring buffer", err)

		return err
	}
	es.rb = rb

	// Calculate the event size if useUnsafe is enabled
	if cfg.useUnsafe {
		var event T
		es.eventSize = int(unsafe.Sizeof(event))
	}

	es.cfg = cfg

	// Initialize the metrics
	es.metrics = newEBPFSourceMetrics(es.tel)
	es.metrics.init()

	return nil
}

func (es *ebpfSource[T]) run(ctx context.Context, outConn msgConn[*EBPFMessage[T]]) {
	for {
		select {
		case <-ctx.Done():
			return
		default:
		}

		record, err := es.rb.Read()
		if err != nil {
			// Check whether the ring buffer is closed
			if errors.Is(err, ringbuf.ErrClosed) {
				return
			}

			es.tel.LogError("failed to read from ring buffer", err)
			continue
		}

		outMsg, err := es.handleRecord(ctx, &record)
		if err != nil {
			es.tel.LogError("failed to handle record", err)
			continue
		}

		if err := outConn.Write(outMsg); err != nil {
			outMsg.Destroy()
			es.tel.LogError("failed to write into output connector", err)
		}
	}
}

func (es *ebpfSource[T]) handleRecord(ctx context.Context, record *ringbuf.Record) (*msg[*EBPFMessage[T]], error) {
	// Create the trace for the incoming record
	_, span := es.tel.NewTrace(ctx, "receive ebpf record")
	defer span.End()

	data, err := es.parseData(record.RawSample)
	if err != nil {
		es.metrics.incrementParsingErrors()
		return nil, err
	}

	// Make the message
	ebpfMsg := newEBPFMessage(data)
	msg := message.NewMessage(ebpfMsg)

	// Save the span into the message
	msg.SaveSpan(span)

	// Update metrics
	es.metrics.incrementReceivedRecords()

	return msg, nil
}

func (es *ebpfSource[T]) parseData(data []byte) (T, error) {
	var res T

	dataLen := len(data)
	es.metrics.addReceivedBytes(int64(dataLen))

	if es.cfg.useUnsafe {
		// Use unsafe struct casting
		if dataLen < es.eventSize {
			return res, errors.New("not enough data")
		}

		res = *(*T)(unsafe.Pointer(&data[0]))
		return res, nil
	}

	if err := binary.Read(bytes.NewReader(data), binary.LittleEndian, &res); err != nil {
		return res, err
	}

	return res, nil
}

func (es *ebpfSource[T]) close() {
	// Close the ring buffer
	es.rb.Close()
}

/////////////
//  STAGE  //
/////////////

// EBPFStage is an ingress stage that reads data from an eBPF ring buffer.
type EBPFStage[T, O any, OPtr ebpfObjsPtr[O]] struct {
	*stage[*EBPFMessage[T], *EBPFConfig[O, OPtr]]

	source *ebpfSource[T]

	objs OPtr
	link link.Link
}

// NewEBPFStage creates a new ebpf ingress stage.
func NewEBPFStage[T, O any, OPtr ebpfObjsPtr[O]](outputConnector msgConn[*EBPFMessage[T]], cfg *EBPFConfig[O, OPtr]) *EBPFStage[T, O, OPtr] {
	source := newEBPFSource[T]()

	return &EBPFStage[T, O, OPtr]{
		stage: newStage("ebpf", source, outputConnector, cfg),

		source: source,
	}
}

// Init initializes the stage.
func (es *EBPFStage[T, O, OPtr]) Init(ctx context.Context) error {
	// Remove resource limits for locked memory
	if err := rlimit.RemoveMemlock(); err != nil {
		es.tel.LogError("failed to remove memlock limits", err)
		return err
	}

	// Load the compiled eBPF ELF file
	spec, err := es.cfg.LoadFn()
	if err != nil {
		es.tel.LogError("failed to load eBPF spec", err)
		return err
	}

	// Load the eBPF objects
	var dummyObjs O
	objs := OPtr(&dummyObjs)
	if err := spec.LoadAndAssign(objs, es.cfg.CollectionOptions); err != nil {
		es.tel.LogError("failed to load eBPF objects", err)
		return err
	}
	es.objs = objs

	// Get the link
	link, err := es.cfg.LinkFn(objs)
	if err != nil {
		es.tel.LogError("failed to attach eBPF program", err)
		return err
	}
	es.link = link

	// Get the ring buffer map
	ringBufferMap := es.cfg.RingBufferGetter(objs)

	// Initialize the source
	sourceCfg := &ebpfSourceConfig{
		ringBufferMap: ringBufferMap,
		useUnsafe:     es.cfg.UseUnsafe,
	}

	if err := es.source.init(sourceCfg); err != nil {
		return err
	}

	return es.stage.Init(ctx)
}

// Close closes the stage.
func (es *EBPFStage[T, O, OPtr]) Close() {
	// Close the source
	es.source.close()

	// Close the objects
	es.objs.Close()

	// Close the ebpf link
	es.link.Close()

	es.source.close()
}
